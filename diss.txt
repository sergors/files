Клеточный автомат представляет собой функцию, которая по заданным правилам преобразует указанные клеточные массивы. Описание клеточного автомата состоит из систем параллельных подстановок, а также может содержать описание контекстных подстановок и функций переходов. Клеточный автомат может принимать параметры, а также возвращает значение типа integer – число завершенных глобальных итераций эволюции. Описание клеточного автомата должно содержать, по крайней мере, одну систему подстановок, которая всегда идет в описание первой.
Клеточные автоматы могут работать только с теми клеточными массивами, которые были переданы им в качестве параметров.

Синтаксис описания клеточного автомата:
CellAuto имя (список_параметров)
{
   системы_подстановок
   [ контекстные_подстановки ]
   [ функции_переходов ]
}

Рассмотрим составные части подробней:
•	список_параметров – определяет элементы, которые требуется передать в клеточный автомат при его выполнении. Элементы списка параметров разделяются запятыми. Для каждого элемента, передаваемого в клеточный автомат, указывается его тип и имя.
•	системы_подстановок – см. «2.3.2 Системы параллельных подстановок».
•	контекстные_подстановки – см. «2.3.4 Контекстные подстановки».
•	функции_переходов – см. «2.3.5 Функции переходов».



Ниже представлен листинг кода, демонстрирующий описанияе клеточного автомата:
CellAuto Hello1(TArray1 A)
{
   System : A
   {
      Q1: (out x1, A.f), (out x2, A.T[0].f) -> (x2, A.f), (x1, A.T[0].f);
   }
};
//Описание клеточного автомата с именем Hello1, который имеет //единственный параметр – клеточный массив A класса TArray1
//Клеточный автомат состоит из системы параллельных подстановок с
//единственной //подстановкой, при помощи которой, каждая клетка //массива A сможет обменяться состоянием (значением переменной f)
//с левой клеткой-соседом.

2.3.2	Системы параллельных подстановок
Система параллельных подстановок представляет собой множество правил переходов клеточного автомата  и может состоять из одной, или нескольких параллельных подстановок. Подстановки из одной системы постановок применяются последовательно к каждой клетке указанного клеточного множества и, в конечном счете,  после применения всех подстановок ко всем клеткам, образуют выполнения глобального оператора.
Каждая система подстановок допускает описание подстановок, которые могут применяться к клеточным массивам различных классов. При этом стоит учитывать, что система подстановок может выполняться только на единственной области значений имен клеток, которая указывается при объявлении системы подстановок. По этой причине, клеточные массивы, к которым применяются подстановки из одной системы параллельных подстановок, должны быть одной мерности и одного размера (это не относится к контексту). В противном случае, корректная работа клеточного автомата не гарантирована, и может привести к критическим ошибкам памяти.
Системы параллельных подстановок также служат для композиции клеточных автоматов (см. «Композиция клеточных автоматов»), и используются при задании тактирующих клеточных автоматов (см. «Тактирующие клеточные автоматы»).

Синтаксис описания системы параллельных подстановок:
System [имя_системы] : указатель_области_значений
                                  [ <определяющий_шаблон> ]
{
   параллельные_подстановки
}

Рассмотрим составные части подробней:
•	имя_системы – имя описываемой системы параллельных подстановок, которое, однако, допускается не указывать.
•	указатель_области_значений – указывает область значений имен клеток, которая будет использоваться в подстановках данной системы. В качестве указателя может выступать клеточный массив, или клеточная область (см. «Клеточные области»).
•	параллельные_подстановки – список параллельных подстановок системы (см. «3.3 Параллельные подстановки»).
•	определяющий_шаблон – необязательный параметр, который используется при задании блочно-синхронных клеточных автоматов (см. «4.4 Блочно-синхронный режим работы»).

2.3.3	Параллельные подстановки
Каждая параллельная подстановка состоит из базы и правой части подстановки, а также может содержать контекст. В свою очередь база, правая часть подстановки и контекст состоят из описаний клеток базы, правой части и контекста соответственно.
Подстановки также могут выполняться в циклах, при этом все итерации цикла выполняются на одном подтакте последовательно и не считаются по отношению друг к другу параллельными. Контекст подстановки вычисляется на каждой итерации цикла. Следует также помнить, что при синхронном режиме работы клеточного автомата, значения клеток будет изменено только после применения всей системы подстановок ко всем клеткам. По этой причине на каждой итерации цикла клетки будут иметь свое первоначальное значение.
Каждая подстановка заканчиваются точкой с запятой и должна быть описана раньше функций переходов и контекстных подстановок, применяемых в данной подстановке. Контекст в подстановках выполняется в первую очередь. Если хоть один предикат в контексте ложен, то данная подстановка не будет выполнена.

Синтаксис описания параллельной подстановки:
имя: база [ * контекст ] -> правая_часть [ : циклы ];

Рассмотрим составные части подробней:
•	база – определяет локальную конфигурацию, клетки которой участвуют в подстановке. Локальная конфигурация задается клетками базы, перечисленными через запятую.
•	контекст – обычно исполняет роль предиката, но также может быть использован для вычисления конкретного индекса из области значений индексов клеток (пространственный контекст), или играть роль вероятностного срабатывания подстановки (вероятностный контекст). Контекстом могут быть как контекстные клетки (вызовы контекстных подстановок), так и клетки клеточных массивов, которые были переданы в клеточный автомат в качестве параметров. Элементы контекста разделяются запятыми.
•	правая_часть – должна соответствовать локальной конфигурации базы.

Синтаксис описания клетки базы:
([ out ] значение, поле_клетки_базы)

Рассмотрим составные части описания клетки базы подробней:
•	поле_клетки_базы – однозначно указывает на поле клетки клеточного массива. Нельзя указывать клетки клеточного массива, который не был явно передан в клеточный автомат в качестве параметра. Если поле указывает на структуру, или массив (а не на их конкретные элементы), то в значение следует указать специальный символ $. Указать клетку можно способами, описанными в разделе «2.3 Поля и методы классов клеточных массивов».
•	[ out ] значение – указание модификатора out при описании означает, что будет объявлена переменная (если она еще не была объявлена) с именем значение, тип которой определяется в соответствие с типом указанного поля клетки. При выполнении подстановки, данной переменной будет присвоено значение этого поля. Переменная считается локальной в отношении описываемого клеточного автомата, что означает ее доступность, как в других системах параллельных подстановок, так и в функциях перехода и контекстных подстановках определенных в теле данного клеточного автомата. Если значение поля клетки не используется, то можно вместо имени переменной указать специальный символ $ - в этом случае, компилятор не будет выделять память под переменную и выполнять операцию присваивания. Если ключевое слово out отсутствует, то клетка играет роль предиката, а в качестве значения могут выступать выражения, функции, переменные и константы, значения которых будут сравниваться со значением указанного поля клетки. В случае равенства, предикат является истинным, в противном случае – ложным. Если хоть один предикат базы ложен, то подстановка не будет выполнена. Предикаты базы всегда проверяется после выполнения контекста.

Синтаксис описания клетки контекста:
([ out ] значение, поле_клетки_контекста)

Рассмотрим составные части описания клетки контекста подробней:
•	поле_клетки_контекста – поле клетки клеточного массива, имя переменной, либо имя контекстной подстановки (см. «Контекстные подстановки»). Нельзя указывать клетки клеточного массива, который не был явно передан в клеточный автомат в качестве параметра. В отличие от базы, здесь не допускается указывать поле клетки, которое является структурой, или массивом (а не их конкретным элементом).
•	[ out ] значение – аналогично описанию в базе, за исключением того, что не допускается указывать символ $.

Синтаксис описания клетки правой части:
(значение, поле_клетки_правой_части)

Рассмотрим составные части описания клетки правой части подробней:
•	поле_клетки_правой_части – локальная конфигурация правой части подстановки должна полностью соответствовать локальной конфигурации базы.
•	значение – переменная, значение которой при выполнении подстановки, будет присвоено указанному полю клетки. Также допускается указывать выражения, или вызовы функций переходов. Тип поля клетки и тип значения должны совпадать. В отличие от базы и контекста, здесь не допускается указывать модификатор out, а также специальный символ $. Если полем клетки является массив, или структура (а не на их конкретные элементы), то в качестве значения может быть только функция переходов, которая возвращает значение типа void. В этом случае, изменять поле клетки следует непосредственно в теле указанной функции переходов, корректность чего полностью возлагается на плечи пользователя.

Синтаксис описания циклов:
for (инициализация; выражение; модификация)

Рассмотрим составные части подробней:
•	циклы – описание циклов, аналогично описанию циклов for в языке С/С++. Указание оператора цикла означает, что подстановка будет выполняться в цикле по всем правилам языка C/С++. Подстановка может иметь несколько операторов цикла, разделенных запятыми. В этом случае циклы стоящие правее являются вложенными по отношению циклов стоящих левее.

Ниже представлен листинг кода, демонстрирующий описание параллельной подстановки с циклом:
CellAuto Test1(TArray2 B)
{
//Описание системы подстановок, состоящей из одной подстановки Q1:
   System : B
   {
      Q1: (out x1, B.#[i].v), ( out y1, A.#[i].f) * //База
          (true, ma) ->                             //Контекст
          (y1, B.#[i].v), (x1, A.#[i].f) :          //Правая часть
           for(int i=0; i<8; i++);             //Цикл по подстановке
   }

   //Описание контекстной подстановки ma:
   (bool, ma)
   {
      if (randf() > 0.5) return true;
      else return false;
   }
};
//Подстановка с именем Q1 имеет базу (локальная конфигурация которой
//состоит из двух клеток), а также контекст (в виде вызова контекстной
//подстановки ma), который исполняет роль предиката
//Подстановка выполняется в цикле, который позволяет клеткам из
//массивов A и B обменяться значениями клеток из своих локальных
//конфигураций
//Подстановка не имеет смысловой нагрузки и описана в качестве примера

2.3.4	Контекстные подстановки
Как уже было отмечено, контекст в подстановках может играть роль предиката, служить для вероятностного срабатывания подстановки, а также использоваться для вычислений имен клеток из области значений. Для того чтобы не усложнять этими операциями тело контекста, вычисления выносятся в контекстные подстановки, которые аналогичны функциям, за исключением того, что они не могут принимать параметров. Контекстные подстановки, как и обычные функции, должны возвращать значение (за исключением типа void), но в физическом смысле не являются функциями, а их код непосредственно вставляется в точку вызова (но в отличие от inline функций языка С компилятор всегда обязан выполнять такую подстановку). Как и в случае tran-функций в контекстные подстановки скрыто передается указатель на текущую клетку клеточной области текущего домена, поэтому к клеткам можно обращаться неявно. Обращение к контекстной подстановке допускается до ее описания, но в любом случае, она должна быть описана в теле клеточного автомата.

Синтаксис описания контекстной подстановки:
(тип, имя)
{
   тело_контекстной_клетки
}

Рассмотрим составные части подробней:
•	тип – тип, возвращаемого контекстной подстановкой, значения. В качестве типа могут использоваться любые стандартные типы (в том числе и void), кроме массивов и классов. Тип в описании контекстной подстановки, и тип переменной, которая принимает значение этой подстановки в контексте, должны совпадать. Это относится и к случаю, когда контекст играет роль предиката – контекстная подстановка и выражение в контексте должны быть одного типа.
•	тело_контекстной_клетки – аналогично телу обычной функции языка С\С++.

Ниже представлен листинг кода, демонстрирующий применение контекстной подстановки:
CellAuto NDiff(TArray1 A)
{
   System : A
   {
      Q1: (out x1, A.f), (out x2, A.T[k].f) * (out k, mk) ->
          (x2, A.f), (x1, A.T[k].f);
   }

   (int, mk)
   {
      if (0 < randf() <= 0.25) return 1;
      else if (0.25 < randf() <= 0.5) return 2;
      else if (0.5 < randf() <= 0.75) return 3;
      else if (0.75 < randf() <= 1) return 4;
      else return 0;
   }
};
//Данный клеточный автомат является клеточно-автоматной
//моделью «Наивная диффузия»
//В подстановке Q1 используется контекст в виде вызова контекстной
//подстановки, которая вычисляет вероятностного соседа, с которым
//клетка обменяется значением.
2.3.5	Функции переходов (tran-функции)
Функции переходов используются в правой части подстановок для вычисления новых значений клеток. Отличие функций переходов от обычных функций заключается в том, что в функцию переходов скрыто, передается указатель на текущую клетку клеточной области текущего домена, что позволяет обращаться к клеткам неявным способом. Ключевое слово tran используется, если функция определена вне тела клеточного автомата. Функции, описанные в теле клеточного автомата, всегда являются tran-функциями, и не доступны для других клеточных автоматов (т.к. в этом случае tran-функция считается локальной).

Синтаксис определения функции переходов:
[ tran ] тип_возвращаемого_значения имя ([ параметры ])
{
   тело_функции
}

Ниже представлен листинг кода, демонстрирующий применение функции переходов:
CellAuto Live(TArray1 A)
{
   System : A
   {
      Q1: ($, A.f) -> (Fun1(), A.f);
   }

   bool Fun1()
   {
      int sum = 0;
      for (int i = 1; i < A.T.Size; i++) sum += A.T[i].f;
      if (A.f == true)
         if (sum == 2 || sum == 3) return true;
         else return false;
      else
         if (sum == 3) return true;
         else return false;
   }
};
//Пример описания клеточного автомата реализующего
//игру Конуэна «Жизнь»
//Функция переходов Fun1 определена в теле клеточного автомата,
//поэтому ключевое слово tran можно опустить.


2.3.6	Операторы передачи управления abreak и acontinue
Операторы abreak и acontinue используются внутри контекстных подстановок и функций переходов клеточных автоматов. Оператор abreak служит для немедленной остановки работы клеточного автомата, а оператор acontinue – для перехода к следующей итерации эволюции. Вне тела клеточного автомата данные операторы игнорируются.
Для синхронных клеточных автоматов операторы abreak и acontinue также отменяют все преобразования клеточных массивов, которые были произведены на текущей итерации.
При распараллеливании клеточного автомата на домены (см. «5.2.3 Домены»), оператор acontinue выполняется только для данного домена, а оператор abreak остановит работу клеточного автомата на всех доменах только в конце итерации, когда будет производиться синхронизации между доменами.

2.3.7	Тактирующие клеточные автоматы
Некоторым клеточным автоматам требуются разделение итераций на такты. На каждом такте  ко всему клеточному множеству, или клеточной области, если это указано (см. «Клеточные области»), применяются подстановки, относящиеся только к данному такту. Такты реализуются при помощи систем параллельных подстановок, где каждая система играет роль такта. Такты (системы подстановок) применяются в порядке их описания в теле клеточного автомата. Выполнение всех тактов образует одну глобальную итерацию клеточного автомата.
Следует помнить, что в синхронных клеточных автоматах на каждом такте используются значения клеточных множеств, полученные на предыдущих тактах. Это существенно отличает такты от циклов. В блочно-синхронных клеточных автоматах такты исполняют роль блоков (см. «4.2 Блочно-синхронный режим работы»).

Ниже представлен листинг кода, демонстрирующий описание тактирующего клеточного автомата:
CellAuto HPP(TArray3 D)
{
   //Фаза движения частиц (такт 1):
   System t1 : D
   {
      Q1: ($, D.mas) -> (Fun1(D), D.mas);
   }
   //Фаза столкновения частиц (такт 2):
   System t2 : D
   {
      Q2: ($, D.mas) -> (Fun2(D), D.mas);
   }

   //Описание функций переходов:
   void Fun1(TArray3 D)
   {
      for (int i = 0; i < 4; i++)
         B.mas[i] = B.T[i+1].mas[i];
   }
   void Fun2(TArray2 B)
   {
      if (B.mas[0] == 0 && B.mas[1] == 1 &&
          B.mas[2] == 0 && B.mas[3] == 1)
         B.mas[0] = 1, B.mas[1] = 0, B.mas[2] = 1, B.mas[3] = 0;
   }
};
//Данный клеточный автомат является клеточно-автоматной
//моделью «HPP-газ»
//и является двухтактным. На первом такте происходит фаза движения
//частиц, а на втором – фаза столкновения частиц.

2.4	Режимы работы клеточных автоматов
2.4.1	Запуск клеточных автоматов
Чтобы описанный клеточный автомат начал работать, его необходимо запустить. Клеточные автоматы могу работать в синхронном, асинхронном, асинхронном упорядоченном и блочно-синхронном режимах. Запуск клеточного автомата аналогичен вызову функций. При запуске в клеточный автомат необходимо передать фактические параметры, а также указать опции запуска (режим работы и размер эволюции (количество итераций, которое совершит клеточный автомат в процессе своей работы)).  Также существует возможность запускать не весь клеточный автомат, а только его конкретные системы параллельных подстановок.
Может понадобиться, что клеточный автомат должен отработать не на всем своем клеточном множестве, а только на каких-то конкретных областях. Для этого вводится понятие областей клеток (см. «2.4.3 Клеточные области»). Области передаются клеточному автомату при запуске в качестве фактических параметров.
При использовании синхронного режима работы следует не забывать об условии детерминированности, которое гласит, что локальный оператор в каждый момент времени может изменять состояние не более чем одной клетке из каждого клеточного массива. Если пренебрегать этим правилом, то при параллельной работе клеточного автомата неизбежно возникновение коллизий.

Синтаксис запуска клеточного автомата:
клеточный_автомат[.имя_системы] ([ параметры ] :
                                режим_работы, размер_эволюции);

Рассмотрим составные части подробней:
•	клеточный_автомат – имя запускаемого клеточного автомата.
•	имя_системы – является необязательной частью запуска и позволяет запускать не весь клеточный автомат, а только указанную систему параллельных подстановок. Если у системы подстановок не было задано имя, то такую систему невозможно запустить отдельно.
•	параметры – фактические параметры клеточного автомата.
•	режим_работы – режим работы клеточного автомата. Может принимать значения, которые являются предопределенными константами и расположены в системном объекте CA.Mode:
	SYNCH – синхронный режим работы. Каждая подстановка клеточного автомата применяется ко всем клеткам «разом». Смена состояний клеток происходит одновременно и образует одну глобальную итерацию.
	ASYNCH – асинхронный режим работы. Каждая подстановка клеточного автомата применяется к каждой клетке в случайном порядке. Смена состояний клеток происходит по очереди. Применение всех подстановок ко всем клеткам указанных клеточных массивов образует одну глобальную итерацию.
	ORDERASYNCH – асинхронный упорядоченный. То же что и асинхронный режим, за исключением того, что клетки выбираются не случайно, а по порядку.
	BLOCKSYNCH – блочно-синхронный (см. «Блочно-синхронный режим работы»).
•	размер_эволюции – задает количество итераций в эволюции. Может принимать в качестве значения целочисленные переменные, константы и выражения.

Ниже представлен листинг кода, демонстрирующий запуск клеточного автомата:
NDiff(A1 : CA.Mode.ASYNCH, 50);
//Запуск клеточного автомата NDiff моделирующего «наивную диффузию»
//Клеточный автомат будет работать в асинхронном режиме на клеточном
//массиве A1 и совершит 50 итераций эволюции.


2.4.2	Клеточные области
Как уже говорилось выше, клеточные автоматы могут работать не только на всей области значений имен клеток указанных клеточных массивов, но и на их конкретных областях. Для этого в описание системы параллельных подстановок клеточного автомата необходимо вместо клеточного массива указать клеточную область, переданную в клеточный автомат в качестве параметра. Клеточная область представляет собой переменную типа Area1D/Area2D/Area3D, которая передается клеточному автомату при запуске в качестве параметра.
В случае 1D пространства область описывается отрезком, заданным при помощи 2 точек (левый и правый край отрезка), при этом каждая точка описывается единственной координатой (ось X). В случае 2D – область описывается прямоугольником, заданным при помощи 2 точек (левый верхний и правый нижний угол прямоугольника), при этом каждая точка описывается при помощи двух координат (оси X и Y). В случае 3D – параллелепипедом, заданным при помощи 2 точек (левый верхний ближний и правый нижний дальний угол), при этом каждая точка описывается при помощи трех координат (оси X,Y и Z).

Синтаксис объявления клеточной области:
area имя;

Синтаксис определения клеточной области:
area имя = new area (тип_области, координаты_области);

Рассмотрим составные части подробней:
•	тип_области – определяет тип задаваемой области. Может принимать значения, которые являются предопределенными константами и расположены в системном объекте CA.Area:
	AREA1D – для области, описываемой для 1D пространства.
	AREA2D – для области, описываемой для 2D пространства.
	AREA3D – для области, описываемой для 3D пространства.
•	координаты_области – набор координат, перечисленных через запятую, которые задают точки описываемой области. В качестве координат могут выступать константы, выражения и переменные целочисленного типа.

Ниже представлен листинг кода, демонстрирующий использование клеточной области:
//Клеточная область:
area area1 = new area(CA.Area.AREA2D, 20, 20, 40, 40);
NDiff(A1, area1 : CA.Mode.ASYNCH, 50);
//Запуск клеточного автомата NDiff, моделирующего «наивную диффузию»,
//который будет работать не на всем клеточном массиве A1, а только
//на его прямоугольной области, заданной при помощи переменной area1.

2.4.3	Блочно-синхронный режим работы
Существует класс клеточных автоматов, которые требуют блочно-синхронного режима работы. В таком клеточном автомате всё его клеточное множество делится на r не пересекающихся подмножеств клеток. Каждая клетка вместе с заданным определяющим шаблоном (в котором она является центровой) образует так называемый блок. Блоки, образованные клетками из одного подмножества, не пересекаются и все вместе составляют первоначальное клеточное множество. Одна глобальная итерация блочно-синхронного клеточного автомата делится на r этапов, где на каждом этапе подстановки применяются только к клеткам из одного подмножества. Ярким примером блочно-синхронного клеточного автомата является клеточно-автоматная модель «ТМ-диффузия» (которую, кстати говоря, можно задать и в виде тактирующего клеточного автомата).
При описании системы параллельных подстановок блочно-синхронного клеточного автомата требуется задать шаблон соседства (определяющий шаблон), который будет использоваться при разбиении клеточного множества на блоки. Определяющий шаблон указывается в угловых скобках, как это было описано в разделе «2.2 Системы параллельных подстановок». Следует иметь в виду, что клеточные автоматы описанные таким образом, могут также работать и в других режимах работы, при этом указанный определяющий шаблон игнорируется.
Также известно, что асинхронные клеточные автоматы не могут быть эффективно распараллелены, поэтому асинхронный режим работы клеточного автомата можно заменить блочно-синхронным. Блочно-синхронные клеточные автоматы распараллеливаются также эффективно, как и синхронные, при этом оставаясь достаточно аппроксимированными к асинхронным клеточным автоматам.

Ниже представлен листинг кода, демонстрирующий описание блочно-синхронного клеточного автомата:
CellAuto TM(TArray1 A, float p)
{
   System : A <A.T>
   {
      Q1: (out u1, A.f),(out u2, A.T[1].f),
          (out u3, A.T[2].f),(out u4, A.T[3].f) *
          (out pflag, mp),(true, pflag),(true, mch) ->
          (u4, A.f), (u1, A.T[1].f), (u2, A.T[2].f), (u3, A.T[3].f);
      Q2: (out u1, A.f),(out u2, A.T[1].f),
          (out u3, A.T[2].f),(out u4, A.T[3].f) *
          (false, pflag),(true, mch) ->
          (u2, A.f), (u3, A.T[1].f), (u4, A.T[2].f), (u1, A.T[3].f);
   }

   (bool, mp)
   {
      if (randf() < p) return true;
      else return false;
   }
   (bool, mch)
   {
      if (i == j) return true;
      else return false;
   }
};
TM(A1 : CA.Mode.BLOCKSYNCH, 50);

//Клеточный автомат TM реализует модель «TM-диффузия» и
//работает в блочно-синхронном режиме работы
//Определяющий шаблон A.T указывает на клетки (i,j), (i,j+1),
//(i+1,j+1), (i+1,j) и делит работу клеточного автомата на 4 этапа
//На первом этапе подстановки применяются к четным клеткам
//(i и j четные)
//На втором этапе к нечетным клеткам (i и j нечетные)
//Третий и четвертый этап не используются, что контролируется
//контекстной подстановкой mch
//Подстановка Q1 «вращает» клетки по часовой стрелке, а Q2 – против
//Контекстная подстановка mp задает, какую подстановку следует
//применить.



2.5	Композиция клеточных автоматов
2.5.1	Последовательная композиция
Различают два вида последовательной композиции клеточных автоматов – локальную последовательную композицию и глобальную последовательную композицию. Такие композиции представимы в виде суперпозиции локальных операторов и суперпозиции глобальных операторов, соответственно. В обоих случаях, операции не коммутативны и не ассоциативны.
В локальной последовательной композиции предполагается применение локальных операторов (параллельных подстановок) к каждой клетке последовательно. Данный тип композиции реализуется при помощи параллельных подстановок одной системы подстановок.
Глобальная последовательная композиция моделирует совместное функционирование нескольких глобальных операторов. Данный тип композиции реализуется при помощи нескольких систем параллельных подстановок. Каждая итерация состоит из последовательно применяемых систем подстановок, причем каждая следующая система подстановок применяется к клеточным массивам, полученным от применения предыдущих систем параллельных подстановок.

Ниже представлен листинг кода, демонстрирующий локальную последовательную композицию:
CellAuto CO2(TArray4 C, float pa, float pb)
{
   //Локальная композиция:
   System : C1
   {
      Q1: (0, C.m) * (true, ma) ->
          (1, C.m);
      Q2: (0, C.m), (0, C.T[k1].m) * (true, mb), (out k1, mk) ->
          (2, C.m), (2, C.T[k1].m);
      Q3: (1, C.m), (2, C.T[k2].m) * (out k2, mk) ->
          (0, C.m), (0, C.T[k2].m);
      Q4: (2, C.m), (1, C.T[k3].m) * (out k3, mk) ->
          (0, C.m), (0, C.T[k3].m);
   }



   //Описание контекстных подстановок:
   (bool, ma)
   {
      if (randf() < pa) return true;
      else return false;
   }
   (bool, mb)
   {
      if (randf() < pb) return true;
      else return false;
   }
   (int, mk)
   {
      float k = randf();
      if (k < 0.25) return 1;
      else if (k < 0.5) return 2;
      else if (k < 0.75) return 3;
      else if (k < 1.0) return 4;
   }
};
CO2(C1, pa, pb : CA.Mode.ASYNCH, 100);

//Клеточный автомат CO2 моделирует химическую реакцию окисления
//окиси углерода на катализаторе, и представляет собой локальную
//асинхронную последовательную композицию четырех параллельных
//подстановок Q1, Q2, Q3, Q4.

2.5.2	Параллельная композиция
2.5.2.1	Параллельная секция
Иногда требуется, чтобы клеточные автоматы функционировали в параллельном режиме. Для этого случая предусмотрена, так называемая, параллельная секция, которая позволяет осуществлять параллельное взаимодействие клеточных автоматов. Параллельная секция описывается при помощи ключевого слова Parallel, за которым следуют параметры композиции, а также область действия параллельной секции, которая задается фигурными скобками. Для каждого клеточного автомата, запущенного в области действия параллельной секции, создается отдельный поток, который будет функционировать параллельно другим потокам данной секции.
Данный тип распараллеливания задает многопоточную систему с общей памятью, что означает, что все клеточные массивы расположены в общей памяти и не создают локальных копий для каждого, параллельно функционирующего, клеточного автомата. Стандарт языка гарантирует исключение коллизий доступа к общей памяти, что осуществляется при помощи внутренних семафоров, генерирующихся компилятором. За все остальные особенности композиции клеточных автоматов, в том числе и условия корректности клеточно-автоматных моделей, отвечает пользователь.
Описание параллельной секции содержит один обязательный параметр – флаг синхронизации, а  также два необязательных параметра - флаг синхронизации систем подстановок и флаг защиты.

Синтаксис описания параллельной секции:
Parallel (флаг_синхронизации [, флаг_синхронизации_систем,
                                             [, флаг_защиты] ])
{
   запуски_клеточных_автоматов
}

Рассмотрим составные части подробней:
•	флаг_синхронизации – позволяет синхронизировать работу запущенных клеточных автоматов по итерациям. Если флаг синхронизации выставлен (значение true), то каждый клеточный автомат параллельной секции сможет перейти к следующей итерации эволюции только тогда, когда все клеточные автоматы данной секции завершат текущую итерацию. Синхронные и блочно-синхронные клеточные автоматы также изменяют состояния своих клеток только после того, как все клеточные автоматы завершат итерацию.
•	флаг_синхронизации_систем – когда данный флаг выставлен (значение true) клеточные автоматы  синхронизируются по завершению каждой своей системы подстановок. Если клеточные автоматы из параллельной секции состоят из разного числа систем параллельных подстановок, то они синхронизируются только по общему их числу, после чего, клеточные автоматы, выполнившие все свои системы подстановок на текущей итерации, в синхронизации не участвуют.  По умолчанию данный флаг всегда выключен (значение false). Также флаг не задействуется, если первый параметр (флаг_синхронизации) является выключенным.
•	флаг_защиты – при активации данного флага каждый клеточный автомат блокирует для записи свои клеточные массивы. Это означает, что клеточные автоматы параллельной секции не смогут изменять значения клеточных массивов других клеточных автоматов, но могут считывать их. Если два разных клеточных автомата блокируют один и тот же клеточный массив, то результат не определен и может привести к полному зависанию программы. По умолчанию данный флаг всегда выключен (значение false).
•	запуски_клеточных_автоматов – запуски клеточных автоматов, которые составляют данную параллельную композицию.

2.5.2.2	Запуск клеточных автоматов в параллельной секции
Клеточные автоматы параллельной секции могут запускаться в разных режимах работы и с разным количеством итераций их эволюций. Если клеточные автоматы имеют разное количество заданных итераций, то синхронизация их работы (если она задана) будет происходить только на общем количестве итераций, а после того, как какой-либо клеточный автомат завершил свою эволюцию, он перестает учувствовать в синхронизации на данной итерации. Клеточные автоматы, функционирующие в разных режимах работы, также подчиняются общим правилам параллельной композиции.
Запуск клеточного автомата в параллельной секции аналогичен обычному запуску клеточного автомата за исключением того, что при запуске в параллельной секции клеточный автомат может быть также распараллелен на домены (см. «5.2.3 Домены»).
Если указать запуск не всего клеточного автомата, а только его конкретных систем параллельных подстановок, то тогда можно получить параллельную композицию, образованную всего одним клеточным автоматом.

Ниже представлен листинг кода, демонстрирующий параллельную композицию двух клеточных автоматов:
Parallel(true)
{
   Auto1(A1,B1 : CA.Mode.SYNCH, 100);
   Auto2(B1,A1 : CA.Mode.SYNCH, 100);
}
//Клеточные автоматы Auto1 и Auto2 запускаются в параллельной секции
//и представляют собой параллельную двунаправленную композицию
//Данные клеточные автоматы пересекаются по клеточным массивам A1 и B1
//и оба работают в синхронном режиме с одинаковым количеством
//итераций эволюции
//Т.к. флаг синхронизации включен (true) - клеточные автоматы будут //синхронизироваться по итерациям

2.5.2.3	Домены
Параллельная секция позволяет также распараллеливать работу клеточных автоматов. Для этого клеточное множество клеточного автомата разделяется на равные блоки, называемые доменами.  Домены пересекаются только по граничным клеткам и не могут изменять клетки других доменов. Каждый домен функционирует параллельно в отдельном потоке, но сам по себе не создает объект параллельной композиции.
Для разбиения клеточного автомата на домены, следует указать при его запуске ключевое слово domain, за которым следует количество доменов, на которые будет «разрезано» клеточное множество данного клеточного автомата. Разделением клеточного множества на домены, а также синхронизацией между этими доменами, занимается компилятор.
Также следует помнить, что распараллеливание асинхронных клеточных автоматов не является эффективным. Дабы преодолеть это ограничение, следует заменить асинхронный режим работы на блочно-синхронный. Блочно-синхронный режим позволяет более эффективно распараллеливать работу клеточного автомата, являясь при этом достаточно близко аппроксимированным к асинхронному режиму.

Синтаксис использования доменов при запуске клеточного автомата:
клеточный_автомат ([ параметры ] : опции)
                            [domain количество_доменов];

Ниже представлен листинг кода, демонстрирующий использования доменов:
Parallel(true)
{
   Auto1(A1,B1 : CA.Mode.SYNCH, 100) domain 2;
   Auto2(B1,A1 : CA.Mode.SYNCH, 100) domain 2;
}
//Аналогично предыдущему примеру, за исключением того, что
//клеточные автоматы Auto1 и Auto2 дополнительно
//распараллеливается на 2 домена каждый














3	Проектирование компилятора языка C-cell
3.1	Структура компилятора
Предлагаемый компилятор языка C-cell является многопроходным и использует внутренний код, который в дальнейшем может быть оттранслирован во внешний код (на данный момент используется язык С++). Логическая схема компилятора изображена на рисунке 3.1. Генератор внешнего кода также использует подпрограммы генерации графического интерфейса пользователя. Сгенерированный таким образом внешний код может быть собран в исполняемый файл при помощи внешнего компилятора (на данный момент используется бесплатный компилятор C++ Builder 5.5).
